后记
========

用Rust实现《Writing An Interpreter In Go》中讲的Moneky语言，和原作中用Go实现有很大的差异，一开始也想着像Go那样
定义各种struct，配合定义的Trait去做，但是发现在判断类型方面Rust的struct和trait确实是障碍制造者，当需要把一个trait
转换成一个struct的时候，需要用到Any的downcast，所以最后切换到Rust本身的特性来思考，最直接的方案是用enum来包装各种
不同的类型。

### 1 String 和 &str
从解释器的构造角度来说，要实现一个语言解释器，拿到输入之后分析的过程就是：

Token => Expression => Statement => ( Program =>) Object (Evaluation)

作为输入而言，其实用&str就够了，中间过程其实也是有很多地方可以使用引用类型的，这样可以减少不必要的内存分配，但是涉及到引
用，就必须带上生命周期，而一旦声明带上了生命周期，就会让实现过程变得很"复杂"，这也是我作为Rust刚入门的阶段来说尽量想要避
免的，因此上述过程中的所有类型基本都使用的String而非&str，写到Evaluator的时候，想要挑战一下，引入生命周期来使用&str
提高逼格，结果后来还是失败了一半（目前代码库中的版本只有Evaluator使用了&str，最开始是在Environment中使用了&str的）。


### 2 浮点数

再说一下浮点数，Monkey原作中没有支持浮点数我没太想明白的，用Go来做的话应该没什么特别复杂的地方，后来看了好几个讲解实现编
程语言的资料，似乎都避开了浮点数。我用Rust实现虽然支持了浮点数类型，但是同样是遇到了一些问题的，比如浮点数在Rust里是不能
实现Eq的，这个问题我当时纠结了很久。到底是把整型和浮点型统一成一个number类型呢，还是区分出来呢？我想的是还是区分开的好，
浮点数计算效率肯定是不如整型的，如果让一个语言完全不支持浮点数，那么使用它的时候就只能是根据精度要求去放大原始数据了。这个
也有一些资料提到过，我原本是只想到了按整10、100、1000……的倍数来放大，但搜索看到的资料中有另一种建议，可以按照位移的倍数
来放大，这样最终计算的时候效率会更高。

### 3 内置类型

在实现+、-、*、/的时候，我是直接在ObjectWrapper的实现里写了几个函数来实现的，我原本打算是花一些时间来做一个内置类型的支
持，这样让这个语言的扩展性更好，有新的类型或者用户自定义类型的时候，遇到这些操作符也能够有依据去判定它是否能够进行这些运算，
最终还是放弃了，类型设计这一块还没有想明白怎么样才是最佳方案，还需要进一步的学习和研究。

### 最值得改进的地方

如果说这个项目后面还有投入的价值，那就是去尝试解决上面提到的问题1了，整个捋清楚的话，应该会对Rust的编程思想有进一步的认识。
而问题3需要在编译器、语言实现方面更进一步，课题有点大。